Sustav se temelji na datoteci passwords u kojoj su zapisani tuplovi (username, hash vrijednost, salt). Hash vrijednost se računa preko kriptografske funkcije sažetka SHA3_256 iz biblioteke pycryptodome na temelju user-ove lozinke konkatenirane s slučajnom vrijednost 'salt' od 16 bajtova. Tih 16 bajtova je također generiano na kriptografski siguran način metodom get_random_bytes iz pycrytodome. Pri svakoj promjeni lozinke, računa se novi salt te nova hash vrijednost. 

User se uspješno ulogira u sustav alatom login ako se vrijednost sažetka unešene lozinke konkatenirane s zapisanim saltom podudara sa vrijednosti sažetka iz datoteke passwords.
Forsiranje promjene lozinke implementirano je tako da se u datoteci zapis dotičnog user-a označi sa zastavicom koja sustavu govori da forsira promjenu lozinke prilikom sljedećeg uspješnog logina (tom prilikom se ta zastavica i briše iz datoteke)

Zaštite navedene na predavanjima, te jesam li ih implementirao ili ne:

- Na disk se pohranjuju slučajna vrijednost i rezultat kriptografske funkcije
sažetka od (lozinka + slučajna vrijednost)

Ovu zaštitu jesam implementirao, jer kako datoteka passwords može dopasti u ruke napadača jako je bitno da bude virtualno nemoguće doći do lozinki preko onog što se nalazi u toj datoteci. Kako su kriptografske funkcije sažetka "one way only", na temelju njihove vrijednosti jako je teško išta reći o početnoj vrijednosti, što je za ovu primjenu točno ono što trebamo. Slučajnu vrijednost ili salt ovdije koristimo kako napadač ne bi mogao preko "rainbow tables" uspjeti povezati hash vrijednosti s čestim lozinkama. Zbog korištenja salta taj napad nije moguć jer bi to značilo da bi za svaku lozinku koju želi isprobati morao izračunati hash vrijednosti sa svim mogućim kombinacijama salt vrijednosti. Korištenje slučajne vrijednosti također napadaču onemogućava da sazna koji korisnici imaju jednake lozinke.

- Forsiranje lozinki određene minimalne kompleksnosti 

Ovu zaštitu sam isto do jedne mjere implementirao, naime sustav se buni ako se pokuša postaviti lozinka kraća od 3 znaka. Inače bi forsirao i više znakova ali mislim da je vama lakše testirati ako ne morate smisljati dugačke lozinke. Ako se mogu postaviti jako kratke lozinke to bi značilo da napadač mora isprobati malo kombinacija da sazna stvarnu lozinku nekog korisnika.

- Nakon svakog neuspjelog pokušaja upisivanja lozinke povećava se vrijeme
čekanja

Ovo nisam implementirao jer u zadatku piše da pretpostavimo da će alat login koristiti samo legitimni korisnici koji neće zlouporabiti alat. U prijevodu to znači da se ne moramo brinuti o tome da napadač pokušava nekome pogoditi lozinku online, već samo offline.

- Nakon određenog broja neuspjelih pokušaja korisnik se blokira, korisnički
račun se zaključava, generira se upozorenje vlasniku sustava

Ovo nisam implementirao iz istog razloga koji je naveden i za zaštitu iznad, te dodatno zato što to otvara mogućnost DoS napada na nekog korisnika.

- Administrator može forsirati zamjenu lozinke

implementirano jer tako i napisano u zadatku.